<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake - 17x17</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; display:flex; gap:20px; padding:20px; }
  .left { display:flex; flex-direction:column; gap:10px; }
  canvas { background:#dfe7df; border:6px solid #222; image-rendering: pixelated; }
  .controls { display:flex; flex-direction:column; gap:8px; max-width:320px;}
  .row { display:flex; gap:8px; align-items:center; }
  label { font-size:14px; }
  button { padding:8px 12px; font-size:14px; cursor:pointer; }
  .status { margin-top:8px; padding:8px; border-radius:8px; background:#fafafa; border:1px solid #ccc; }
  .small { font-size:13px; color:#444; }
  fieldset { border:1px solid #ccc; padding:8px; border-radius:8px; }
  legend { font-size:14px; padding:0 6px; }
  .bigmsg { font-weight:700; margin-top:10px; }
</style>
</head>
<body>
  <div class="left">
    <canvas id="game" width="680" height="680" tabindex="0"></canvas>
    <div class="status">
      <div id="info" class="small">Pommes mang√©es : 0</div>
      <div id="msg" class="bigmsg"></div>
    </div>
  </div>

  <div class="controls">
    <fieldset>
      <legend>Couleur du serpent (personnalisable)</legend>
      <div>
        <input type="radio" name="palette" id="pal-default" value="default" checked>
        <label for="pal-default">Rouge (original)</label>
      </div>
      <div>
        <input type="radio" name="palette" id="pal-blue" value="blue">
        <label for="pal-blue">Bleu</label>
      </div>
      <div>
        <input type="radio" name="palette" id="pal-green" value="green">
        <label for="pal-green">Vert</label>
      </div>
      <div>
        <input type="radio" name="palette" id="pal-yellow" value="yellow">
        <label for="pal-yellow">Jaune</label>
      </div>
    </fieldset>

    <div class="row">
      <input type="checkbox" id="debug">
      <label for="debug">Avancer seulement sur appui direction</label>
    </div>

    <div class="row">
      <label for="speed">Vitesse (mouvements / s):</label>
      <input type="range" id="speed" min="2" max="12" value="6">
      <span id="speedVal">6</span>
    </div>

    <div class="row">
      <button id="startBtn">D√©marrer / Recommencer</button>
      <button id="pauseBtn">Pause</button>
    </div>

    <div class="row small">
      <div>Contr√¥les : fl√®ches directionnelles</div>
    </div>

    <div class="row small">
      <div><strong>Conseil :</strong> il est recommand√© de jouer en mode plein √©cran. Pour cela, appuyez sur F12.</strong></div>
    </div>
  </div>

<script>
/*
  Implementation notes:
  - Grid 17x17, tile size 40
  - Spritesheet: 4 columns x 7 rows, tile 40x40
  - Original customizable palette:
      #7A0404, #BD0F0F, #EB4242, #F78888 (these four will be replaced)
    Invariable: #F8F8F8 (white) and #000000 (black)
  - We do pixel-replacement on the spritesheet to generate a recolored spritesheet image to use.
  - For sprite selection:
      row 0 (y=0): head up(0), left(1), right(2), down(3)
      row 1 (y=1): body straight up(0), left(1), right(2), down(3) [we'll map vertical/horizontal appropriately]
      row 2 (y=2): corners: up+left (0), up+right (1), down+left (2), down+right (3)
      row 3 (y=3): tail up(0), left(1), right(2), down(3)
      row 6 (y=6): head happy up,left,right,down
    (We do not use rows 4 & 5 in this implementation ‚Äî body/tail variants still look reasonable.)
*/

const TILE = 40;
const COLS = 17;
const ROWS = 17;
const CANVAS_SIZE = TILE * COLS; // 680

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });

const info = document.getElementById('info');
const msgEl = document.getElementById('msg');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const debugCheckbox = document.getElementById('debug');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');

speedRange.addEventListener('input', () => speedVal.textContent = speedRange.value);

let spritesheetImg = new Image();
spritesheetImg.src = 'assets/snake/Snake.png';

let appleImg = new Image();
appleImg.src = 'assets/snake/Apple.png';

let recoloredSheet = null; // Image object after palette swap

// Original palette hex (four customizable) and invariants
const ORIG_CUSTOM = ['#7A0404','#BD0F0F','#EB4242','#F78888'];
const INVARIANT = ['#F8F8F8','#000000'];

// Replacement palettes
const PALETTES = {
  default: ORIG_CUSTOM.slice(),
  blue: ['#04047A','#0F0FBD','#4242EB','#8888F7'],
  green: ['#037003','#05A305','#40D640','#91F291'],
  yellow: ['#C77706','#DBBA12','#EBEB1E','#F7F794']
};

// helper convert hex to rgba array [r,g,b,a]
function hexToRgba(hex) {
  hex = hex.replace('#','');
  if (hex.length===3) hex = hex.split('').map(ch=>ch+ch).join('');
  const n = parseInt(hex,16);
  return [ (n>>16)&255, (n>>8)&255, n&255, 255 ];
}

// create recolored spritesheet by replacing exact colors in the image data
function makeRecoloredSheet(replacementPalette, callback) {
  // Wait for spritesheetImg to load
  if (!spritesheetImg.complete) {
    spritesheetImg.onload = () => makeRecoloredSheet(replacementPalette, callback);
    spritesheetImg.onerror = () => { alert('Erreur : impossible de charger /assets/snake/Snake.png'); };
    return;
  }
  const w = spritesheetImg.width, h = spritesheetImg.height;
  const tmp = document.createElement('canvas');
  tmp.width = w; tmp.height = h;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(spritesheetImg,0,0);
  const imgd = tctx.getImageData(0,0,w,h);
  const data = imgd.data;

  // map originals to replacements
  const map = {};
  for (let i=0;i<ORIG_CUSTOM.length;i++){
    map[ORIG_CUSTOM[i].toLowerCase()] = replacementPalette[i];
  }
  // invariants left unchanged

  // Build lookup of numeric RGB strings to replacement RGB
  const lookup = {};
  for (const origHex in map) {
    const o = hexToRgba(origHex);
    const rpl = hexToRgba(map[origHex]);
    lookup[`${o[0]},${o[1]},${o[2]},${o[3]}`] = rpl;
  }
  // invariants map to themselves to ensure exact match not replaced
  for (const inv of INVARIANT) {
    const o = hexToRgba(inv.toLowerCase());
    lookup[`${o[0]},${o[1]},${o[2]},${o[3]}`] = o;
  }

  // Replace: exact color match only
  for (let i=0;i<data.length;i+=4){
    const key = `${data[i]},${data[i+1]},${data[i+2]},${data[i+3]}`;
    if (lookup[key]) {
      const rpl = lookup[key];
      data[i]=rpl[0]; data[i+1]=rpl[1]; data[i+2]=rpl[2]; data[i+3]=rpl[3];
    }
  }
  tctx.putImageData(imgd,0,0);
  const img = new Image();
  img.onload = () => {
    callback(img);
  };
  img.src = tmp.toDataURL();
}

// Game state
let snake = []; // array of {x,y}
let dir = {x:1,y:0}; // initial direction to the right
let nextDir = {x:1,y:0};
let apple = null;
let applesEaten = 0;
let running = false;
let paused = false;
let lastStepTimestamp = 0;
let stepInterval = 1000 / parseInt(speedRange.value,10);
let debugMode = false;
let victory = false;

function resetGame() {
  // start in middle horizontally, length 4 going right
  const midX = Math.floor(COLS/2);
  const midY = Math.floor(ROWS/2);
  snake = [];
  // create tail-to-head: tail first at leftmost
  for (let i=0;i<4;i++){
    snake.push({x: midX - (3-i), y: midY});
  }
  dir = {x:1,y:0};
  nextDir = {x:1,y:0};
  applesEaten = 0;
  apple = placeApple();
  running = true;
  paused = false;
  victory = false;
  msgEl.textContent = '';
  updateInfo();
}

function placeApple() {
  const occupied = new Set(snake.map(s => `${s.x},${s.y}`));
  if (snake.length >= COLS*ROWS) return null;
  let x,y,attempts=0;
  do {
    x = Math.floor(Math.random()*COLS);
    y = Math.floor(Math.random()*ROWS);
    attempts++;
    if (attempts>10000) break;
  } while (occupied.has(`${x},${y}`));
  return {x,y};
}

function updateInfo() {
  info.textContent = `Pommes mang√©es : ${applesEaten} ‚Äî Taille du serpent : ${snake.length}/${COLS*ROWS}`;
}

// keyboard handling
window.addEventListener('keydown', (e) => {
  if (!running) return;
  const key = e.key;
  let wanted = null;
  if (key === 'ArrowUp') wanted = {x:0,y:-1};
  if (key === 'ArrowDown') wanted = {x:0,y:1};
  if (key === 'ArrowLeft') wanted = {x:-1,y:0};
  if (key === 'ArrowRight') wanted = {x:1,y:0};
  if (!wanted) return;
  e.preventDefault();

  // Prevent reversing direction
  if (wanted.x === -dir.x && wanted.y === -dir.y) {
    // ignore reversing
    return;
  }
  nextDir = wanted;

  // If debug mode, advance one step immediately
  if (debugCheckbox.checked) {
    step();
  }
});

// step function - advances the snake by one tile
function step() {
  if (!running || paused || victory) return;
  dir = nextDir;
  const head = snake[snake.length-1];
  const nx = head.x + dir.x;
  const ny = head.y + dir.y;

  // check collision with walls
  if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) {
    endGame(false);
    return;
  }
  // check collision with self
  for (let i=0;i<snake.length;i++){
    if (snake[i].x === nx && snake[i].y === ny) {
      endGame(false);
      return;
    }
  }
  // move
  snake.push({x:nx,y:ny});
  // ate apple?
  if (apple && apple.x===nx && apple.y===ny) {
    applesEaten++;
    // don't remove tail (grow)
    apple = placeApple();
    updateInfo();
    // check victory
    if (snake.length >= COLS*ROWS) {
      endGame(true);
      return;
    }
  } else {
    // normal move: remove tail
    snake.shift();
  }
}

// end game
function endGame(didWin) {
  running = false;
  victory = didWin;
  if (didWin) {
    msgEl.textContent = `Victoire ! Tu as rempli le plateau üéâ ‚Äî Pommes mang√©es : ${applesEaten}`;
  } else {
    msgEl.textContent = `Partie termin√©e ‚Äî Pommes mang√©es : ${applesEaten}`;
  }
}

// main loop with requestAnimationFrame
function loop(ts) {
  if (!lastStepTimestamp) lastStepTimestamp = ts;
  const speed = parseInt(speedRange.value,10);
  stepInterval = 1000 / speed;
  debugMode = debugCheckbox.checked;
  if (!debugMode && running && !paused && ts - lastStepTimestamp >= stepInterval) {
    step();
    lastStepTimestamp = ts;
  }
  render();
  requestAnimationFrame(loop);
}

// utility: draw tile from spritesheet (recoloredSheet) by (col,row) into (x,y)
function drawSprite(sxCol, syRow, dx, dy) {
  if (!recoloredSheet) return;
  ctx.drawImage(recoloredSheet, sxCol*TILE, syRow*TILE, TILE, TILE, dx, dy, TILE, TILE);
}

// determine sprite indices for a given segment index in snake array
function chooseSpriteForSegment(index) {
  // index from 0 (tail) to snake.length-1 (head)
  const seg = snake[index];

  if (index === snake.length-1) {
    // HEAD
    const head = seg;
    const before = snake[index-1];
    const dx = head.x - before.x;
    const dy = head.y - before.y;
    if (dx === 0 && dy === -1) return {col:0, row: victory?6:0}; // up
    if (dx === -1 && dy === 0) return {col:1, row: victory?6:0}; // left
    if (dx === 1 && dy === 0) return {col:2, row: victory?6:0}; // right
    if (dx === 0 && dy === 1) return {col:3, row: victory?6:0}; // down
  } else if (index === 0) {
  // TAIL
  const tail = seg;
  const after = snake[1];

  // direction from tail to body
  const dx = tail.x - after.x;  // <-- invers√© pour pointer vers l'ext√©rieur
  const dy = tail.y - after.y;

  // row 3 = straight tail, rows 4 & 5 = turning tail
  if (dx === 0 && dy === -1) return {col:3, row:3}; // tail pointing down (was up)
  if (dx === 0 && dy === 1)  return {col:0, row:3}; // tail pointing up (was down)
  if (dx === -1 && dy === 0) return {col:2, row:3}; // tail pointing right (was left)
  if (dx === 1 && dy === 0)  return {col:1, row:3}; // tail pointing left (was right)

  // corners (row 4 & 5)
  if (dx === 1 && dy === -1) return {col:0, row:5};
  if (dx === -1 && dy === -1) return {col:1, row:5};
  if (dx === 1 && dy === 1)  return {col:2, row:4};
  if (dx === -1 && dy === 1) return {col:3, row:4};

  return {col:0, row:3}; // fallback
} else {
    // BODY
    const prev = snake[index-1];
    const cur = seg;
    const next = snake[index+1];
    const v1 = {x: prev.x - cur.x, y: prev.y - cur.y}; // direction to previous
    const v2 = {x: next.x - cur.x, y: next.y - cur.y}; // direction to next

    // straight
    if ((v1.x !== 0 && v2.x !== 0)) return {col:1, row:1}; // horizontal
    if ((v1.y !== 0 && v2.y !== 0)) return {col:0, row:1}; // vertical

    // corner mapping row2
    const dirs = [v1, v2];
    const uniq = {};
    dirs.forEach(d => { uniq[`${d.x},${d.y}`] = true; });
    const hasTop = uniq['0,-1']; const hasBottom = uniq['0,1'];
    const hasLeft = uniq['-1,0']; const hasRight = uniq['1,0'];

    if (hasTop && hasLeft) return {col:0, row:2};
    if (hasTop && hasRight) return {col:1, row:2};
    if (hasBottom && hasLeft) return {col:2, row:2};
    if (hasBottom && hasRight) return {col:3, row:2};

    return {col:0, row:1}; // fallback vertical
  }
}


function renderGrid() {
  // optional grid background
  ctx.fillStyle = '#dfe7df';
  ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
  // draw subtle grid lines
  ctx.strokeStyle = 'rgba(0,0,0,0.05)';
  ctx.lineWidth = 1;
  for (let i=0;i<=COLS;i++){
    ctx.beginPath();
    ctx.moveTo(i*TILE,0);
    ctx.lineTo(i*TILE,CANVAS_SIZE);
    ctx.stroke();
  }
  for (let j=0;j<=ROWS;j++){
    ctx.beginPath();
    ctx.moveTo(0,j*TILE);
    ctx.lineTo(CANVAS_SIZE,j*TILE);
    ctx.stroke();
  }
}

function render() {
  // draw background and grid
  renderGrid();

  // draw apple
  if (apple && appleImg.complete) {
    ctx.drawImage(appleImg, apple.x*TILE, apple.y*TILE, TILE, TILE);
  } else if (apple) {
    // fallback: draw a red circle if apple not loaded
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(apple.x*TILE + TILE/2, apple.y*TILE + TILE/2, TILE*0.35, 0, Math.PI*2);
    ctx.fill();
  }

  // draw snake segments in order
  for (let i=0;i<snake.length;i++){
    const seg = snake[i];
    const sprite = chooseSpriteForSegment(i);
    drawSprite(sprite.col, sprite.row, seg.x*TILE, seg.y*TILE);
  }
}

// init recolored sheet then start loop
function initAndStart() {
  // pick palette choice
  const chosen = document.querySelector('input[name="palette"]:checked').value;
  const replacement = PALETTES[chosen] || PALETTES.default;
  makeRecoloredSheet(replacement, (img) => {
    recoloredSheet = img;
    resetGame();
  });
}

// start/restart buttons
startBtn.addEventListener('click', () => {
  initAndStart();
  canvas.focus();
});
pauseBtn.addEventListener('click', () => {
  if (!running) return;
  paused = !paused;
  pauseBtn.textContent = paused ? 'Reprendre' : 'Pause';
});

// ensure images loaded
appleImg.onload = () => { /* nothing special */ };
spritesheetImg.onload = () => { /* nothing special */ };

// automatically initialize (but spritesheet recolor happens on first Start)
resetGame();
requestAnimationFrame(loop);

// focus canvas to capture keys
canvas.addEventListener('click', () => canvas.focus());

// expose some helpful debug via console
window.SnakeGame = {
  reset: resetGame,
  stepOne: step,
  getState: () => ({snake: JSON.parse(JSON.stringify(snake)), apple, applesEaten, running, victory})
};
</script>
</body>
</html>
